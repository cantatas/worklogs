<!DOCTYPE html>
<html lang="en">

<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="generator" content="Hugo 0.55.6" />

  <title>CANTATAS</title>

  
  
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pure/1.0.0/pure-min.css">

  <!--[if lte IE 8]>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pure/1.0.0/grids-responsive-old-ie-min.css">
  <![endif]-->
  <!--[if gt IE 8]><!-->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pure/1.0.0/grids-responsive-min.css">
  <!--<![endif]-->

  <!--[if lte IE 8]>
  <link rel="stylesheet" href="https://html6.club/css/side-menu-old-ie.css">
  <![endif]-->
  <!--[if gt IE 8]><!-->
  <link rel="stylesheet" href="https://html6.club/css/side-menu.css">
  <!--<![endif]-->

  <link rel="stylesheet" href="https://html6.club/css/blackburn.css">

  
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">

  
  <link href="https://fonts.googleapis.com/css?family=Raleway" rel="stylesheet" type="text/css">

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

 
  
  <link rel="alternate" type="application/rss+xml" title="CANTATAS"
    href='https://html6.club/index.xml' />
  

  
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/androidstudio.min.css">
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  
  <script>hljs.initHighlightingOnLoad();</script>
  

  <link rel="shortcut icon" href="https://html6.club/img/favicon.ico" type="image/x-icon" />

  
  

</head>


<body>
<div id="layout">

  
<a href="#menu" id="menuLink" class="menu-link">
  
  <span></span>
</a>
<div id="menu">

  
  <a class="pure-menu-heading brand" href="https://html6.club/">Catatas</a>


  <div class="pure-menu">
    <ul class="pure-menu-list">
      
      
        <li class="pure-menu-item">
          <a class="pure-menu-link" href="https://html6.club/"><i class='fa fa-home fa-fw'></i>Home</a>
      
        </li>
      
      
        <li class="pure-menu-item">
          <a class="pure-menu-link" href="https://html6.club/post/"><i class='fa fa-list fa-fw'></i>Posts</a>
      
        </li>
      
      
        <li class="pure-menu-item">
          <a class="pure-menu-link" href="https://html6.club/about/"><i class='fa fa-user fa-fw'></i>About</a>
      
        </li>
      
    </ul>
  </div>

  <div class="pure-menu social">
  <ul class="pure-menu-list">

    
    <li class="pure-menu-item">
      <a class="pure-menu-link" href='https://html6.club/index.xml'><i
          class="fa fa-rss fa-fw"></i>RSS</a>
    </li>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

  </ul>
</div>


  <div>
  <div class="small-print">
    <small>&copy; 2019. All rights reserved.</small>
  </div>
  <div class="small-print">
    <small>Built with&nbsp;<a href="https://gohugo.io/" target="_blank">Hugo</a></small>
    <small>Theme&nbsp;<a href="https://github.com/yoshiharuyamashita/blackburn" target="_blank">Blackburn</a></small>
  </div>
</div>

</div>


  <div id="main">


<div class="header">
  <h1>CANTATAS</h1>
  <h2>胡适：你的闲暇时间，决定了你人生的高度</h2>
</div>

<div class="content">
  
    <article>
  <header>
    <h2><a href="https://html6.club/post/axios-vulnerability/">Axios发现了一个 DoS 漏洞</a></h2>

    <div class="post-meta">

  <div>
    <i class="fa fa-calendar fa-fw"></i>
    <time>2019/05/10 14:58</time>
  </div>

  

  

  
  
  
  <div>
    <i class="fa fa-tags fa-fw"></i>
    
      <a class="post-taxonomy-tag" href="https://html6.club/tags/ajax">ajax</a>&nbsp;&#47;
    
      <a class="post-taxonomy-tag" href="https://html6.club/tags/axios">axios</a>&nbsp;&#47;
    
      <a class="post-taxonomy-tag" href="https://html6.club/tags/axios-dos">axios dos</a>&nbsp;&#47;
    
      <a class="post-taxonomy-tag" href="https://html6.club/tags/axios%E6%BC%8F%E6%B4%9E">axios漏洞</a>
    
  </div>
  
  

</div>

  </header>

  <p>
   axios是一种流行的基于promise的现代JavaScript HTTP客户端，通常用于浏览器和Nodejs服务器项目，npm每周下载超过300万次。
早在2017年，开发人员Jeremy Apthorp就在项目的GitHub问题队列中讨论并共享了该漏洞。
受影响的axios版本容易受到拒绝服务（DoS）的影响，因为即使maxContentLength超过了内容，内容也会继续处理，从而导致I / O和CPU使用率增加。
关于此漏洞 Anthorp在GitHub问题中共享了一个代码片段，以显示axios API的示例用例，限制了收到的HTTP响应的大小：
require('axios').get( 'https://upload.wikimedia.org/wikipedia/commons/f/fe/A_Different_Slant_on_Carina.jpg', { maxContentLength: 2000 } ) .then(d =&gt; console.log('done')) .catch(e =&gt; console.log(e.toString()))  但是，无论内容长度限制如何，HTTP连接都将保持打开状态，直到传输完整的文件大小数据，从而允许任何控制远程域或窃听不安全线路的人提供大文件大小并阻止来自完成了很长时间。
在撰写本文时，尚未发布针对此漏洞的官方修复，但在项目的GitHub存储库中打开了以解决问题的Pull Request形式的社区参与，并等待合并和发布。
我们该怎么办？ 在您对axios的每次调用中应用以下缓解措施，以针对此漏洞进行防御性编码：
axios({ url: ..., maxContentLength: 2000, }).catch((error) =&gt; { error.request.res.destroy(); });  
  </p>

  
</article>

  
    <article>
  <header>
    <h2><a href="https://html6.club/post/github-private-org-push/">Github 私有仓库代码提交</a></h2>

    <div class="post-meta">

  <div>
    <i class="fa fa-calendar fa-fw"></i>
    <time>2019/01/10 20:52</time>
  </div>

  

  

  
  
  
  <div>
    <i class="fa fa-tags fa-fw"></i>
    
      <a class="post-taxonomy-tag" href="https://html6.club/tags/github">github</a>
    
  </div>
  
  

</div>

  </header>

  <p>
   1. 在github上创建仓库名为 “githubDemo” 选择 “Private” 账号示例:  github账号：githubName github密码：8888888  2. clone拉取私有仓库到本地  拉取URL规则：”账号@github.com/账号/仓库名.git“
 git clone https://githubName@github.com/githubName/githubDemo.git  3. push提交到远程私有仓库  将你的代码拷贝到 “githubDemo” 文件夹中,执行如下代码:   提交RUL规则：“账号:密码@github.com/账号/仓库名.git”
 git remote add origin https://githubName:88888888@github.com/githubName/githubDemo.git git add . git commit -m &quot;first commit&quot; git push --set-upstream origin master  
  </p>

  
</article>

  
    <article>
  <header>
    <h2><a href="https://html6.club/post/the-12-things-you-need-to-consider-when-evaluating-any-new-javascript-library/">评估任何新的 JavaScript 库时，需要考虑的12件事</a></h2>

    <div class="post-meta">

  <div>
    <i class="fa fa-calendar fa-fw"></i>
    <time>2018/09/25 12:02</time>
  </div>

  

  

  
  
  
  <div>
    <i class="fa fa-tags fa-fw"></i>
    
      <a class="post-taxonomy-tag" href="https://html6.club/tags/javascript%E5%BA%93">JavaScript库</a>
    
  </div>
  
  

</div>

  </header>

  <p>
  1 引言 作者给出了从 12 个角度全面分析 JS 库的可用性，分别是：
 特性 稳定性 性能 包生态 社区 学习曲线 文档 工具 发展历史 团队 兼容性 趋势  下面总结一下作者的观点。
2 概述 &amp; 精读 特性 当你调研一个 JS 库，功能当然是最重要的，就好比 React 的用于开发 UI 界面非常方便，这是流行起来的一部分因素。
但同时 React 解决的问题很聚焦，于是把例如 Router 和 Store 部分交给社区给解决方案，这就让 Vue 的官方维护生态模式发展了起来。但这更多取决于你的偏好，像 lodash 这种精简的库也会长盛不衰，重要的是这个库提供的能力是否解决了你的业务问题。
评分：
 A - 化腐朽为神奇。 B - 更优雅的解决方案。 C - 比现有方案差。  稳定性 这个库如果经常出 BUG，那显然无法在生产环境使用。最好经过严格的测试，保证这个库一定不会出错，这样我们就可以专心排查业务的问题了。
评分：
 A - BUG 很少，方便调试。 B - 不会影响你的稳定性，比如出 BUG 概率和你的业务代码相近。 C - 引入该库会让你背线上故障。  性能 这个库如果经常出 BUG，那显然无法在生产环境使用。最好经过严格的测试，保证这个库一定不会出错，这样我们就可以专心排查业务的问题了。
  </p>

  
  <footer>
    <a href="https://html6.club/post/the-12-things-you-need-to-consider-when-evaluating-any-new-javascript-library/">Read more<i class="fa fa-angle-double-right fa-fw"></i></a>
  </footer>
  
</article>

  
    <article>
  <header>
    <h2><a href="https://html6.club/post/debounce-and-throttle/">什么是防抖和节流？有什么区别？如何实现？</a></h2>

    <div class="post-meta">

  <div>
    <i class="fa fa-calendar fa-fw"></i>
    <time>2018/07/15 14:02</time>
  </div>

  

  

  
  
  
  <div>
    <i class="fa fa-tags fa-fw"></i>
    
      <a class="post-taxonomy-tag" href="https://html6.club/tags/%E8%8A%82%E6%B5%81">节流</a>&nbsp;&#47;
    
      <a class="post-taxonomy-tag" href="https://html6.club/tags/%E9%98%B2%E6%8A%96">防抖</a>
    
  </div>
  
  

</div>

  </header>

  <p>
  防抖  触发高频事件后n秒内函数只会执行一次，如果n秒内高频事件再次被触发，则重新计算时间
 思路：  每次触发事件时都取消之前的延时调用方法
 function debounce(fn) { let timeout = null; // 创建一个标记用来存放定时器的返回值 return function () { clearTimeout(timeout); // 每当用户输入的时候把前一个 setTimeout clear 掉 timeout = setTimeout(() =&gt; { // 然后又创建一个新的 setTimeout, 这样就能保证输入字符后的 interval 间隔内如果还有字符输入的话，就不会执行 fn 函数 fn.apply(this, arguments); }, 500); }; } function sayHi() { console.log('防抖成功'); } var inp = document.getElementById('inp'); inp.addEventListener('input', debounce(sayHi)); // 防抖  节流  高频事件触发，但在n秒内只会执行一次，所以节流会稀释函数的执行频率
 思路：  每次触发事件时都判断当前是否有等待执行的延时函数
 function throttle(fn) { let canRun = true; // 通过闭包保存一个标记 return function () { if (!
  </p>

  
  <footer>
    <a href="https://html6.club/post/debounce-and-throttle/">Read more<i class="fa fa-angle-double-right fa-fw"></i></a>
  </footer>
  
</article>

  
    <article>
  <header>
    <h2><a href="https://html6.club/post/use-set-increase-speed/">JavaScript使用 Set 取代 Array 提高性能</a></h2>

    <div class="post-meta">

  <div>
    <i class="fa fa-calendar fa-fw"></i>
    <time>2018/05/12 17:14</time>
  </div>

  

  

  
  
  
  <div>
    <i class="fa fa-tags fa-fw"></i>
    
      <a class="post-taxonomy-tag" href="https://html6.club/tags/javascript">JavaScript</a>&nbsp;&#47;
    
      <a class="post-taxonomy-tag" href="https://html6.club/tags/set">set</a>&nbsp;&#47;
    
      <a class="post-taxonomy-tag" href="https://html6.club/tags/array">array</a>&nbsp;&#47;
    
      <a class="post-taxonomy-tag" href="https://html6.club/tags/%E6%95%B0%E7%BB%84">数组</a>
    
  </div>
  
  

</div>

  </header>

  <p>
  Array和Set工作方式存在大量的交叉。但是使用Set会比Array在代码运行速度更有优势。
Set 有何不同 最根本的区别是数组是一个索引集合，这说明数组中的数据值按索引排序。
const arr = [A, B, C, D]; console.log(arr.indexOf(A)); // Result: 0 console.log(arr.indexOf(C)); // Result: 2  相比之下，set是一个键的集合。set不使用索引，而是使用键对数据排序。set 中的元素按插入顺序是可迭代的，它不能包含任何重复的数据。换句话说，set中的每一项都必须是惟一的。
主要的好处是什么 set 相对于数组有几个优势，特别是在运行时间方面：  查看元素：使用indexOf()或includes()检查数组中的项是否存在是比较慢的。 删除元素:在Set中，可以根据每项的的 value 来删除该项。在数组中，等价的方法是使用基于元素的索引的splice()。与前一点一样，依赖于索引的速度很慢。 保存 NaN：不能使用indexOf()或 includes() 来查找值 NaN，而 Set 可以保存此值。 删除重复项:Set对象只存储惟一的值,如果不想有重复项存在，相对于数组的一个显著优势，因为数组需要额外的代码来处理重复。  时间复杂度？ 数组用来搜索元素的方法时间复杂度为0(N)。换句话说，运行时间的增长速度与数据大小的增长速度相同。
相比之下，Set用于搜索、删除和插入元素的方法的时间复杂度都只有O(1)，这意味着数据的大小实际上与这些方法的运行时间无关。
Set 究竟有多快？ 虽然运行时间可能会有很大差异，具体取决于所使用的系统，所提供数据的大小以及其他变量，但我希望我的测试结果能够让你真实地了解Set的速度。 我将分享三个简单的测试和我得到的结果。
测试 在运行任何测试之前，创建一个数组和一个 Set，每个数组和 Set 都有100万个元素。为了简单起见，我从0开始，一直数到999999。
let arr = [], set = new Set(), n = 1000000; for (let i = 0; i &lt; n; i++) { arr.
  </p>

  
  <footer>
    <a href="https://html6.club/post/use-set-increase-speed/">Read more<i class="fa fa-angle-double-right fa-fw"></i></a>
  </footer>
  
</article>

  
    <article>
  <header>
    <h2><a href="https://html6.club/post/parse-base64/">JS使用 btoa和atob 编码解码 Base64</a></h2>

    <div class="post-meta">

  <div>
    <i class="fa fa-calendar fa-fw"></i>
    <time>2017/07/10 16:52</time>
  </div>

  

  

  
  
  
  <div>
    <i class="fa fa-tags fa-fw"></i>
    
      <a class="post-taxonomy-tag" href="https://html6.club/tags/base64">Base64</a>&nbsp;&#47;
    
      <a class="post-taxonomy-tag" href="https://html6.club/tags/btoa">btoa</a>&nbsp;&#47;
    
      <a class="post-taxonomy-tag" href="https://html6.club/tags/atob">atob</a>
    
  </div>
  
  

</div>

  </header>

  <p>
  btoa和atob是window对象的两个函数，其中btoa是binary to ascii，用于将binary的数据用ascii码表示，即Base64的编码过程，而atob则是ascii to binary，用于将ascii码解析成binary数据，看一个例子：
// Define the string var string = 'Hello World!'; // Encode the String var encodedString = btoa(string); console.log(encodedString); // Outputs: &quot;SGVsbG8gV29ybGQh&quot; // Decode the String var decodedString = atob(encodedString); console.log(decodedString); // Outputs: &quot;Hello World!&quot;  可以看到，字符串“Hello World!”已被Base64编码和解码。但是，atob和btoa 不能编码Unicode字符 ：
var string = &quot;Hello, 中国！&quot;; window.btoa(string); //报错： &gt; VM13204:2 Uncaught DOMException: Failed to execute 'btoa' on 'Window': The string to be encoded contains characters outside of the Latin1 range.
  </p>

  
  <footer>
    <a href="https://html6.club/post/parse-base64/">Read more<i class="fa fa-angle-double-right fa-fw"></i></a>
  </footer>
  
</article>

  
    <article>
  <header>
    <h2><a href="https://html6.club/post/scrollintoview/">使用scrollIntoView滚动页面</a></h2>

    <div class="post-meta">

  <div>
    <i class="fa fa-calendar fa-fw"></i>
    <time>2017/06/05 21:11</time>
  </div>

  

  

  
  
  
  <div>
    <i class="fa fa-tags fa-fw"></i>
    
      <a class="post-taxonomy-tag" href="https://html6.club/tags/scrollintoview">scrollIntoView</a>&nbsp;&#47;
    
      <a class="post-taxonomy-tag" href="https://html6.club/tags/dom%E6%BB%9A%E5%8A%A8">DOM滚动</a>
    
  </div>
  
  

</div>

  </header>

  <p>
  DOM规范中并没有规定各浏览器需要实现怎样的滚动页面区域，各浏览器实现了相应的方法，可以使用不同的方式控制页面区域的滚动。这些方法作为HTMLElement类型的扩展存在，所以它能在所有元素上使用。 1、scrollIntoView(alignWithTop) 滚动浏览器窗口或容器元素，以便在当前视窗的可见范围看见当前元素。如果alignWithTop为true，或者省略它，窗口会尽可能滚动到自身顶部与元素顶部平齐。&mdash;&mdash;-目前各浏览器均支持
2、scrollIntoViewIfNeeded(alignCenter) 只在当前元素在视窗的可见范围内不可见的情况下，才滚动浏览器窗口或容器元素，最终让当前元素可见。如果当前元素在视窗中可见，这个方法不做任何处理。如果将可选参数alignCenter设置为true，则表示尽量将元素显示在视窗中部（垂直方向）&mdash;&mdash;Safari、Chrome实现了这个方法
3、scrollByLines(lineCount) 将元素的内容滚动指定的行数的高度，lineCount的值可以为正值或是负值。&mdash;Safari、Chrome实现了这个方法
4、scrollByPages(pageCount) 将元素的内容滚动指定的页面的高度，具体高度由元素的高度决定。&mdash;Safari、Chrome实现了这个方法
scrollIntoView()和scrollIntoVIewIfNeeded()作用的是元素的窗口，而scrollByLines()、scrollByPages()影响元素自身，下面是几个示例： 将页面主体滚动5行: document.body.scrollByLines(5);  确保当前元素可见： document.getElementById('test').scrollIntoView();  确保只在当前元素不可见的情况下才使其可见： document.getElementById('test').scrollIntoViewIfNeeded();  scrollIntoViewIfNeeded可以接受一个Boolean型参数，和scrollIntoView不同，true为默认值，但不是滚动到顶部，而是让元素在可视区域中居中对齐；false时元素可能顶部或底部对齐。
将页面主体往回滚1页： doument.body.scrollByPages(-1);  由于只有scrollIntoView被各浏览器均支持，所以这个方法最为常用
  </p>

  
</article>

  
    <article>
  <header>
    <h2><a href="https://html6.club/post/display-and-visibility/">display: none与visibility: hidden的区别</a></h2>

    <div class="post-meta">

  <div>
    <i class="fa fa-calendar fa-fw"></i>
    <time>2017/05/15 20:01</time>
  </div>

  

  

  
  
  
  <div>
    <i class="fa fa-tags fa-fw"></i>
    
      <a class="post-taxonomy-tag" href="https://html6.club/tags/css">css</a>
    
  </div>
  
  

</div>

  </header>

  <p>
  visibility: hidden和display: none的区别不仅仅在于display: none隐藏后的元素不占据任何空间，而visibility: hidden隐藏后的元素空间依旧保留 ，实际上没那么简单，visibility是一个非常有故事性的属性 1、visibility具有继承性，给父元素设置 visibility:hidden; 子元素也会继承这个属性。但是如果重新给子元素设置visibility: visible,则子元素又会显示出来。这个和display: none有着质的区别
2、visibility: hidden 不会影响计数器的计数，如图所示，visibility: hidden 虽然让一个元素不见了，但是其计数器仍在运行。这和display: none完全不一样
3、CSS3 的 transition 支持 visibility 属性，但是并不支持 display，由于 transition 可以延迟执行，因此可以配合visibility使用纯 css 实现 hover 延时显示效果。提高用户体验。
  </p>

  
</article>

  
    <article>
  <header>
    <h2><a href="https://html6.club/post/use-weinre-doc/">使用weinre真机调试移动端H5页面</a></h2>

    <div class="post-meta">

  <div>
    <i class="fa fa-calendar fa-fw"></i>
    <time>2017/02/05 17:39</time>
  </div>

  

  

  
  
  
  <div>
    <i class="fa fa-tags fa-fw"></i>
    
      <a class="post-taxonomy-tag" href="https://html6.club/tags/weinre">weinre</a>&nbsp;&#47;
    
      <a class="post-taxonomy-tag" href="https://html6.club/tags/%E7%9C%9F%E6%9C%BA%E8%B0%83%E8%AF%95">真机调试</a>
    
  </div>
  
  

</div>

  </header>

  <p>
   1. 安装 npm npm install -g weinre  yarn yarn add weinre  2. 启动 weinre --httpPort 8081 --boundHost -all- /*这里的端口8081可以自定义*/  3. 浏览器打开weinre首页 4. 调试页面js引入 5. 远程真机调试  进入要调试的设备：
  远程设备调试：
  手机端效果：
 
  </p>

  
</article>

  

  


</div>

</div>
</div>
<script src="https://html6.club/js/ui.js"></script>
<script src="https://html6.club/js/menus.js"></script>






</body>
</html>

