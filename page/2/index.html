<!DOCTYPE html>
<html>
	<head>
	<meta name="generator" content="Hugo 0.55.6" />
		<meta charset="utf-8">
		<title>CANTATAS</title>
		<meta name="viewport" content="width=device-width">
		
			<link href="https://html6.club/index.xml" rel="alternate" type="application/rss+xml" title="CANTATAS" />
			<link href="https://html6.club/index.xml" rel="feed" type="application/rss+xml" title="CANTATAS" />
		
		<link rel="stylesheet" href="https://html6.club/css/hybrid.css">
		<link rel="stylesheet" href="https://html6.club/css/style.css">
		<link rel="stylesheet" href="https://html6.club/css/colors-dark.css">

		
	</head>
	<body>
		<header id="header">
			<h1><a href="https://html6.club/">CANTATAS</a></h1>
			<p></p>
		</header>

		<div id="page">
			<div id="sidebar">
				<nav>
	
		<ul class="nav">
			
				<li><a href="https://html6.club/"><span>Home</span></a></li>
			
				<li><a href="https://html6.club/post/"><span>Posts</span></a></li>
			
				<li><a href="https://html6.club/about/"><span>About</span></a></li>
			
		</ul>
	
</nav>

			</div>

			<div id="content">
				
	
		<article class="post">
			<h1><a href="https://html6.club/post/scrollintoview/">使用scrollIntoView滚动页面</a> </h1>

			<div class="post-content">
				<p>DOM规范中并没有规定各浏览器需要实现怎样的滚动页面区域，各浏览器实现了相应的方法，可以使用不同的方式控制页面区域的滚动。这些方法作为HTMLElement类型的扩展存在，所以它能在所有元素上使用。 1、scrollIntoView(alignWithTop) 滚动浏览器窗口或容器元素，以便在当前视窗的可见范围看见当前元素。如果alignWithTop为true，或者省略它，窗口会尽可能滚动到自身顶部与元素顶部平齐。&mdash;&mdash;-目前各浏览器均支持
2、scrollIntoViewIfNeeded(alignCenter) 只在当前元素在视窗的可见范围内不可见的情况下，才滚动浏览器窗口或容器元素，最终让当前元素可见。如果当前元素在视窗中可见，这个方法不做任何处理。如果将可选参数alignCenter设置为true，则表示尽量将元素显示在视窗中部（垂直方向）&mdash;&mdash;Safari、Chrome实现了这个方法
3、scrollByLines(lineCount) 将元素的内容滚动指定的行数的高度，lineCount的值可以为正值或是负值。&mdash;Safari、Chrome实现了这个方法
4、scrollByPages(pageCount) 将元素的内容滚动指定的页面的高度，具体高度由元素的高度决定。&mdash;Safari、Chrome实现了这个方法
scrollIntoView()和scrollIntoVIewIfNeeded()作用的是元素的窗口，而scrollByLines()、scrollByPages()影响元素自身，下面是几个示例： 将页面主体滚动5行: document.body.scrollByLines(5);  确保当前元素可见： document.getElementById('test').scrollIntoView();  确保只在当前元素不可见的情况下才使其可见： document.getElementById('test').scrollIntoViewIfNeeded();  scrollIntoViewIfNeeded可以接受一个Boolean型参数，和scrollIntoView不同，true为默认值，但不是滚动到顶部，而是让元素在可视区域中居中对齐；false时元素可能顶部或底部对齐。
将页面主体往回滚1页： doument.body.scrollByPages(-1);  由于只有scrollIntoView被各浏览器均支持，所以这个方法最为常用 </p>
			</div>

			<p class="meta">Posted on <span class="postdate">05. June 2018</span></p>
		</article>
	
		<article class="post">
			<h1><a href="https://html6.club/post/display-and-visibility/">display: none与visibility: hidden的区别</a> </h1>

			<div class="post-content">
				<p>visibility: hidden和display: none的区别不仅仅在于display: none隐藏后的元素不占据任何空间，而visibility: hidden隐藏后的元素空间依旧保留 ，实际上没那么简单，visibility是一个非常有故事性的属性 1、visibility具有继承性，给父元素设置 visibility:hidden; 子元素也会继承这个属性。但是如果重新给子元素设置visibility: visible,则子元素又会显示出来。这个和display: none有着质的区别
2、visibility: hidden 不会影响计数器的计数，如图所示，visibility: hidden 虽然让一个元素不见了，但是其计数器仍在运行。这和display: none完全不一样
3、CSS3 的 transition 支持 visibility 属性，但是并不支持 display，由于 transition 可以延迟执行，因此可以配合visibility使用纯 css 实现 hover 延时显示效果。提高用户体验。 </p>
			</div>

			<p class="meta">Posted on <span class="postdate">15. May 2018</span></p>
		</article>
	
		<article class="post">
			<h1><a href="https://html6.club/post/use-set-increase-speed/">JavaScript使用 Set 取代 Array 提高性能</a> </h1>

			<div class="post-content">
				<p>Array和Set工作方式存在大量的交叉。但是使用Set会比Array在代码运行速度更有优势。
Set 有何不同 最根本的区别是数组是一个索引集合，这说明数组中的数据值按索引排序。
const arr = [A, B, C, D]; console.log(arr.indexOf(A)); // Result: 0 console.log(arr.indexOf(C)); // Result: 2  相比之下，set是一个键的集合。set不使用索引，而是使用键对数据排序。set 中的元素按插入顺序是可迭代的，它不能包含任何重复的数据。换句话说，set中的每一项都必须是惟一的。
主要的好处是什么 set 相对于数组有几个优势，特别是在运行时间方面：  查看元素：使用indexOf()或includes()检查数组中的项是否存在是比较慢的。 删除元素:在Set中，可以根据每项的的 value 来删除该项。在数组中，等价的方法是使用基于元素的索引的splice()。与前一点一样，依赖于索引的速度很慢。 保存 NaN：不能使用indexOf()或 includes() 来查找值 NaN，而 Set 可以保存此值。 删除重复项:Set对象只存储惟一的值,如果不想有重复项存在，相对于数组的一个显著优势，因为数组需要额外的代码来处理重复。  时间复杂度？ 数组用来搜索元素的方法时间复杂度为0(N)。换句话说，运行时间的增长速度与数据大小的增长速度相同。
相比之下，Set用于搜索、删除和插入元素的方法的时间复杂度都只有O(1)，这意味着数据的大小实际上与这些方法的运行时间无关。
Set 究竟有多快？ 虽然运行时间可能会有很大差异，具体取决于所使用的系统，所提供数据的大小以及其他变量，但我希望我的测试结果能够让你真实地了解Set的速度。 我将分享三个简单的测试和我得到的结果。
测试 在运行任何测试之前，创建一个数组和一个 Set，每个数组和 Set 都有100万个元素。为了简单起见，我从0开始，一直数到999999。
let arr = [], set = new Set(), n = 1000000; for (let i = 0; i &lt; n; i++) { arr.  … </p>
			</div>

			<p class="meta">Posted on <span class="postdate">12. May 2018</span></p>
		</article>
	
		<article class="post">
			<h1><a href="https://html6.club/post/use-weinre-doc/">使用weinre真机调试移动端H5页面</a> </h1>

			<div class="post-content">
				<p> 1. 安装 npm npm install -g weinre  yarn yarn add weinre  2. 启动 weinre --httpPort 8081 --boundHost -all- /*这里的端口8081可以自定义*/  3. 浏览器打开weinre首页 4. 调试页面js引入 5. 远程真机调试  进入要调试的设备：
  远程设备调试：
  手机端效果：
  </p>
			</div>

			<p class="meta">Posted on <span class="postdate">05. February 2018</span></p>
		</article>
	

	
	<nav class="pagination" role="pagination">
		
			<a class="newer-posts" href="https://html6.club/"><span aria-hidden="true">&larr;</span> Newer Posts</a>
		
		<span class="page-number">Page 2 of 2</span>
		
	</nav>



			</div>

			<footer id="footer">
				<p class="copyright">
					
						&amp;copy; 2019. All rights reserved.
					
				</p>
			</footer>
		</div>

		
	</body>
</html>
