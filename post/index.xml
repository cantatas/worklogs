<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on CANTATAS</title>
    <link>https://html6.club/post/</link>
    <description>Recent content in Posts on CANTATAS</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>&amp;copy; 2019. All rights reserved.</copyright>
    <lastBuildDate>Fri, 10 May 2019 14:58:31 +0800</lastBuildDate>
    
	<atom:link href="https://html6.club/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Axios发现了一个 DoS 漏洞</title>
      <link>https://html6.club/post/axios-vulnerability/</link>
      <pubDate>Fri, 10 May 2019 14:58:31 +0800</pubDate>
      
      <guid>https://html6.club/post/axios-vulnerability/</guid>
      <description> axios是一种流行的基于promise的现代JavaScript HTTP客户端，通常用于浏览器和Nodejs服务器项目，npm每周下载超过300万次。
早在2017年，开发人员Jeremy Apthorp就在项目的GitHub问题队列中讨论并共享了该漏洞。
受影响的axios版本容易受到拒绝服务（DoS）的影响，因为即使maxContentLength超过了内容，内容也会继续处理，从而导致I / O和CPU使用率增加。
关于此漏洞 Anthorp在GitHub问题中共享了一个代码片段，以显示axios API的示例用例，限制了收到的HTTP响应的大小：
require(&#39;axios&#39;).get( &#39;https://upload.wikimedia.org/wikipedia/commons/f/fe/A_Different_Slant_on_Carina.jpg&#39;, { maxContentLength: 2000 } ) .then(d =&amp;gt; console.log(&#39;done&#39;)) .catch(e =&amp;gt; console.log(e.toString()))  但是，无论内容长度限制如何，HTTP连接都将保持打开状态，直到传输完整的文件大小数据，从而允许任何控制远程域或窃听不安全线路的人提供大文件大小并阻止来自完成了很长时间。
在撰写本文时，尚未发布针对此漏洞的官方修复，但在项目的GitHub存储库中打开了以解决问题的Pull Request形式的社区参与，并等待合并和发布。
我该怎么办？ 在您对axios的每次调用中应用以下缓解措施，以针对此漏洞进行防御性编码：
axios({ url: ..., maxContentLength: 2000, }).catch((error) =&amp;gt; { error.request.res.destroy(); });  </description>
    </item>
    
    <item>
      <title>Github 私有仓库代码提交</title>
      <link>https://html6.club/post/github-private-org-push/</link>
      <pubDate>Thu, 10 Jan 2019 20:52:16 +0800</pubDate>
      
      <guid>https://html6.club/post/github-private-org-push/</guid>
      <description> 1. 在github上创建仓库名为 “githubDemo” 选择 “Private” 账号示例:  github账号：githubName github密码：8888888  2. clone拉取私有仓库到本地  拉取URL规则：”账号@github.com/账号/仓库名.git“
 git clone https://githubName@github.com/githubName/githubDemo.git  3. push提交到远程私有仓库  将你的代码拷贝到 “githubDemo” 文件夹中,执行如下代码:   提交RUL规则：“账号:密码@github.com/账号/仓库名.git”
 git remote add origin https://githubName:88888888@github.com/githubName/githubDemo.git git add . git commit -m &amp;quot;first commit&amp;quot; git push --set-upstream origin master  </description>
    </item>
    
    <item>
      <title>JavaScript引擎与线程</title>
      <link>https://html6.club/post/js-engines-and-threads/</link>
      <pubDate>Mon, 05 Mar 2018 10:41:43 +0800</pubDate>
      
      <guid>https://html6.club/post/js-engines-and-threads/</guid>
      <description>聊聊 JavaScript 的单线程与异步，浏览器的多线程、引擎和内核。 如果你做过可视化开发，你是否遇到过这样一个棘手的问题：因为需要向页面中添加大量的图表或点线元素而导致页面卡顿、性能下降。一般来说你可能考虑一个方案，从 SVG 换到了 canvas，这或多或少可以解决你面临的痛点，但是背后的原因你到底了解多少？隐藏在浏览器背后的秘密到底有多少，内核和引擎我们又该了解到什么程度？换个方面来说，我们都知道 JavaScript 是单线程的，那么 HTML5 规范引入了一个叫 Web Worker 的标准是否意味着 JavaScript 真正跨入多线程编程的时代了呢？
今天在看《深入 HTML5 Web Worker 应用实践：多线程编程》一文时发现自己对 JavaScript 解释器和浏览器的线程机制理解的不是特别透彻，很容易混淆浏览器多线程机制并错误认为由于 Web Worker 的设计使得 JavaScript 拥有了多线程的能力。事后搜了不少资料进行学习，整理成此文，主要介绍浏览器的各个引擎、线程间的工作机制以及 JavaScript 单线程的一些事。
浏览器的那些引擎与内核 因为要谈到 JavaScript 的实现，必须先了解它的宿主环境，我们就从宿主环境之一——浏览器开始说起吧。
浏览器的主要功能是向服务器发送请求，在自身窗口中展示我们所选择的网络资源。一个浏览器的主要组件可分为如下几个部分：
 用户界面(User Interface) - 包括地址栏、前进/后退按钮、书签菜单等。除了浏览器主窗口显示的您请求的页面外，其他显示的各个部分都属于用户界面。 浏览器引擎(Browser engine) - 在用户界面和呈现引擎之间传送指令。 呈现引擎(Rendering engine) - 负责显示请求的内容。如果请求的内容是 HTML，它就负责解析 HTML 和 CSS 内容，并将解析后的内容显示在屏幕上。 网络(Networking) - 用于网络调用，比如 HTTP 请求。其接口与平台无关，并为所有平台提供底层实现。 用户界面后端(UI Backend) - 用于绘制基本的窗口小部件，比如组合框和窗口。其公开了与平台无关的通用接口，而在底层使用操作系统的用户界面方法。 JavaScript 解释器(JavaScript Interpreter)。用于解析和执行 JavaScript 代码。 数据存储(Data Persistence)。这是持久层。浏览器需要在硬盘上保存各种数据，例如 Cookie。新的 HTML 规范 (HTML5) 定义了“网络数据库”，这是一个完整（但是轻便）的浏览器内数据库。  注意：和大多数浏览器不同，Chrome 浏览器的每个标签页都分别对应一个呈现引擎实例。每个标签页都是一个独立的进程。</description>
    </item>
    
    <item>
      <title>使用scrollIntoView滚动页面</title>
      <link>https://html6.club/post/scrollintoview/</link>
      <pubDate>Mon, 05 Jun 2017 21:11:33 +0800</pubDate>
      
      <guid>https://html6.club/post/scrollintoview/</guid>
      <description>DOM规范中并没有规定各浏览器需要实现怎样的滚动页面区域，各浏览器实现了相应的方法，可以使用不同的方式控制页面区域的滚动。这些方法作为HTMLElement类型的扩展存在，所以它能在所有元素上使用。 1、scrollIntoView(alignWithTop) 滚动浏览器窗口或容器元素，以便在当前视窗的可见范围看见当前元素。如果alignWithTop为true，或者省略它，窗口会尽可能滚动到自身顶部与元素顶部平齐。&amp;mdash;&amp;mdash;-目前各浏览器均支持
2、scrollIntoViewIfNeeded(alignCenter) 只在当前元素在视窗的可见范围内不可见的情况下，才滚动浏览器窗口或容器元素，最终让当前元素可见。如果当前元素在视窗中可见，这个方法不做任何处理。如果将可选参数alignCenter设置为true，则表示尽量将元素显示在视窗中部（垂直方向）&amp;mdash;&amp;mdash;Safari、Chrome实现了这个方法
3、scrollByLines(lineCount) 将元素的内容滚动指定的行数的高度，lineCount的值可以为正值或是负值。&amp;mdash;Safari、Chrome实现了这个方法
4、scrollByPages(pageCount) 将元素的内容滚动指定的页面的高度，具体高度由元素的高度决定。&amp;mdash;Safari、Chrome实现了这个方法
scrollIntoView()和scrollIntoVIewIfNeeded()作用的是元素的窗口，而scrollByLines()、scrollByPages()影响元素自身，下面是几个示例： 将页面主体滚动5行: document.body.scrollByLines(5);  确保当前元素可见： document.getElementById(&#39;test&#39;).scrollIntoView();  确保只在当前元素不可见的情况下才使其可见： document.getElementById(&#39;test&#39;).scrollIntoViewIfNeeded();  scrollIntoViewIfNeeded可以接受一个Boolean型参数，和scrollIntoView不同，true为默认值，但不是滚动到顶部，而是让元素在可视区域中居中对齐；false时元素可能顶部或底部对齐。
将页面主体往回滚1页： doument.body.scrollByPages(-1);  由于只有scrollIntoView被各浏览器均支持，所以这个方法最为常用</description>
    </item>
    
    <item>
      <title>display: none与visibility: hidden的区别</title>
      <link>https://html6.club/post/display-and-visibility/</link>
      <pubDate>Mon, 15 May 2017 20:01:22 +0800</pubDate>
      
      <guid>https://html6.club/post/display-and-visibility/</guid>
      <description>visibility: hidden和display: none的区别不仅仅在于display: none隐藏后的元素不占据任何空间，而visibility: hidden隐藏后的元素空间依旧保留 ，实际上没那么简单，visibility是一个非常有故事性的属性 1、visibility具有继承性，给父元素设置 visibility:hidden; 子元素也会继承这个属性。但是如果重新给子元素设置visibility: visible,则子元素又会显示出来。这个和display: none有着质的区别
2、visibility: hidden 不会影响计数器的计数，如图所示，visibility: hidden 虽然让一个元素不见了，但是其计数器仍在运行。这和display: none完全不一样
3、CSS3 的 transition 支持 visibility 属性，但是并不支持 display，由于 transition 可以延迟执行，因此可以配合visibility使用纯 css 实现 hover 延时显示效果。提高用户体验。</description>
    </item>
    
    <item>
      <title>使用weinre真机调试移动端H5页面</title>
      <link>https://html6.club/post/use-weinre-doc/</link>
      <pubDate>Sun, 05 Feb 2017 17:39:16 +0800</pubDate>
      
      <guid>https://html6.club/post/use-weinre-doc/</guid>
      <description> 1. 安装 npm npm install -g weinre  yarn yarn add weinre  2. 启动 weinre --httpPort 8081 --boundHost -all- /*这里的端口8081可以自定义*/  3. 浏览器打开weinre首页 4. 调试页面js引入 5. 远程真机调试  进入要调试的设备：
  远程设备调试：
  手机端效果：
 </description>
    </item>
    
  </channel>
</rss>