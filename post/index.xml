<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on CANTATAS</title>
    <link>https://html6.club/post/</link>
    <description>Recent content in Posts on CANTATAS</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>&amp;copy; 2019. All rights reserved.</copyright>
    <lastBuildDate>Fri, 10 May 2019 14:58:31 +0800</lastBuildDate>
    
	<atom:link href="https://html6.club/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Axios发现了一个 DoS 漏洞</title>
      <link>https://html6.club/post/axios-vulnerability/</link>
      <pubDate>Fri, 10 May 2019 14:58:31 +0800</pubDate>
      
      <guid>https://html6.club/post/axios-vulnerability/</guid>
      <description> axios是一种流行的基于promise的现代JavaScript HTTP客户端，通常用于浏览器和Nodejs服务器项目，npm每周下载超过300万次。
早在2017年，开发人员Jeremy Apthorp就在项目的GitHub问题队列中讨论并共享了该漏洞。
受影响的axios版本容易受到拒绝服务（DoS）的影响，因为即使maxContentLength超过了内容，内容也会继续处理，从而导致I / O和CPU使用率增加。
关于此漏洞 Anthorp在GitHub问题中共享了一个代码片段，以显示axios API的示例用例，限制了收到的HTTP响应的大小：
require(&#39;axios&#39;).get( &#39;https://upload.wikimedia.org/wikipedia/commons/f/fe/A_Different_Slant_on_Carina.jpg&#39;, { maxContentLength: 2000 } ) .then(d =&amp;gt; console.log(&#39;done&#39;)) .catch(e =&amp;gt; console.log(e.toString()))  但是，无论内容长度限制如何，HTTP连接都将保持打开状态，直到传输完整的文件大小数据，从而允许任何控制远程域或窃听不安全线路的人提供大文件大小并阻止来自完成了很长时间。
在撰写本文时，尚未发布针对此漏洞的官方修复，但在项目的GitHub存储库中打开了以解决问题的Pull Request形式的社区参与，并等待合并和发布。
我该怎么办？ 在您对axios的每次调用中应用以下缓解措施，以针对此漏洞进行防御性编码：
axios({ url: ..., maxContentLength: 2000, }).catch((error) =&amp;gt; { error.request.res.destroy(); });  </description>
    </item>
    
    <item>
      <title>Github 私有仓库代码提交</title>
      <link>https://html6.club/post/github-private-org-push/</link>
      <pubDate>Thu, 10 Jan 2019 20:52:16 +0800</pubDate>
      
      <guid>https://html6.club/post/github-private-org-push/</guid>
      <description> 1. 在github上创建仓库名为 “githubDemo” 选择 “Private” 账号示例:  github账号：githubName github密码：8888888  2. clone拉取私有仓库到本地  拉取URL规则：”账号@github.com/账号/仓库名.git“
 git clone https://githubName@github.com/githubName/githubDemo.git  3. push提交到远程私有仓库  将你的代码拷贝到 “githubDemo” 文件夹中,执行如下代码:   提交RUL规则：“账号:密码@github.com/账号/仓库名.git”
 git remote add origin https://githubName:88888888@github.com/githubName/githubDemo.git git add . git commit -m &amp;quot;first commit&amp;quot; git push --set-upstream origin master  </description>
    </item>
    
    <item>
      <title>使用scrollIntoView滚动页面</title>
      <link>https://html6.club/post/scrollintoview/</link>
      <pubDate>Mon, 05 Jun 2017 21:11:33 +5600</pubDate>
      
      <guid>https://html6.club/post/scrollintoview/</guid>
      <description>DOM规范中并没有规定各浏览器需要实现怎样的滚动页面区域，各浏览器实现了相应的方法，可以使用不同的方式控制页面区域的滚动。这些方法作为HTMLElement类型的扩展存在，所以它能在所有元素上使用。 1、scrollIntoView(alignWithTop) 滚动浏览器窗口或容器元素，以便在当前视窗的可见范围看见当前元素。如果alignWithTop为true，或者省略它，窗口会尽可能滚动到自身顶部与元素顶部平齐。&amp;mdash;&amp;mdash;-目前各浏览器均支持
2、scrollIntoViewIfNeeded(alignCenter) 只在当前元素在视窗的可见范围内不可见的情况下，才滚动浏览器窗口或容器元素，最终让当前元素可见。如果当前元素在视窗中可见，这个方法不做任何处理。如果将可选参数alignCenter设置为true，则表示尽量将元素显示在视窗中部（垂直方向）&amp;mdash;&amp;mdash;Safari、Chrome实现了这个方法
3、scrollByLines(lineCount) 将元素的内容滚动指定的行数的高度，lineCount的值可以为正值或是负值。&amp;mdash;Safari、Chrome实现了这个方法
4、scrollByPages(pageCount) 将元素的内容滚动指定的页面的高度，具体高度由元素的高度决定。&amp;mdash;Safari、Chrome实现了这个方法
scrollIntoView()和scrollIntoVIewIfNeeded()作用的是元素的窗口，而scrollByLines()、scrollByPages()影响元素自身，下面是几个示例： 将页面主体滚动5行: document.body.scrollByLines(5);  确保当前元素可见： document.getElementById(&#39;test&#39;).scrollIntoView();  确保只在当前元素不可见的情况下才使其可见： document.getElementById(&#39;test&#39;).scrollIntoViewIfNeeded();  scrollIntoViewIfNeeded可以接受一个Boolean型参数，和scrollIntoView不同，true为默认值，但不是滚动到顶部，而是让元素在可视区域中居中对齐；false时元素可能顶部或底部对齐。
将页面主体往回滚1页： doument.body.scrollByPages(-1);  由于只有scrollIntoView被各浏览器均支持，所以这个方法最为常用</description>
    </item>
    
    <item>
      <title>display: none与visibility: hidden的区别</title>
      <link>https://html6.club/post/display-and-visibility/</link>
      <pubDate>Mon, 15 May 2017 20:01:22 +0300</pubDate>
      
      <guid>https://html6.club/post/display-and-visibility/</guid>
      <description>visibility: hidden和display: none的区别不仅仅在于display: none隐藏后的元素不占据任何空间，而visibility: hidden隐藏后的元素空间依旧保留 ，实际上没那么简单，visibility是一个非常有故事性的属性 1、visibility具有继承性，给父元素设置 visibility:hidden; 子元素也会继承这个属性。但是如果重新给子元素设置visibility: visible,则子元素又会显示出来。这个和display: none有着质的区别
2、visibility: hidden 不会影响计数器的计数，如图所示，visibility: hidden 虽然让一个元素不见了，但是其计数器仍在运行。这和display: none完全不一样
3、CSS3 的 transition 支持 visibility 属性，但是并不支持 display，由于 transition 可以延迟执行，因此可以配合visibility使用纯 css 实现 hover 延时显示效果。提高用户体验。</description>
    </item>
    
    <item>
      <title>使用weinre真机调试移动端H5页面</title>
      <link>https://html6.club/post/use-weinre-doc/</link>
      <pubDate>Sun, 05 Feb 2017 17:39:16 +0800</pubDate>
      
      <guid>https://html6.club/post/use-weinre-doc/</guid>
      <description> 1. 安装 npm npm install -g weinre  yarn yarn add weinre  2. 启动 weinre --httpPort 8081 --boundHost -all- /*这里的端口8081可以自定义*/  3. 浏览器打开weinre首页 4. 调试页面js引入 5. 远程真机调试  进入要调试的设备：
  远程设备调试：
  手机端效果：
 </description>
    </item>
    
  </channel>
</rss>